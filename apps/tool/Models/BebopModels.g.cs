//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.1.3
//
//
//       bebopc source:
//           https://github.com/betwixt-labs/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//
// This source code was auto-generated by bebopc, Version=3.1.3.
//
namespace Wowthing.Tool.Models {

  /// <summary>A static class which contains schema defined constants.</summary>
  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "3.1.3")]
  public static class BopConstants {
    public static readonly byte[] BEBOP_SCHEMA = new byte[] {
    3, 1, 0, 0, 0, 66, 101, 98, 111, 112, 73, 116, 101, 109,
    0, 1, 0, 0, 36, 0, 0, 0, 0, 12, 105, 100, 67, 108, 97,
    115, 115, 73, 100, 83, 117, 98, 99, 108, 97, 115, 115, 73,
    100, 0, 251, 255, 255, 255, 0, 98, 105, 110, 100, 84, 121,
    112, 101, 69, 120, 112, 97, 110, 115, 105, 111, 110, 0,
    254, 255, 255, 255, 0, 112, 114, 105, 109, 97, 114, 121,
    83, 116, 97, 116, 81, 117, 97, 108, 105, 116, 121, 0, 254,
    255, 255, 255, 0, 114, 97, 99, 101, 77, 97, 115, 107, 0,
    248, 255, 255, 255, 0, 99, 108, 97, 115, 115, 77, 97, 115,
    107, 0, 250, 255, 255, 255, 0, 102, 108, 97, 103, 115, 0,
    254, 255, 255, 255, 0, 105, 110, 118, 101, 110, 116, 111,
    114, 121, 84, 121, 112, 101, 0, 254, 255, 255, 255, 0,
    105, 116, 101, 109, 76, 101, 118, 101, 108, 0, 252, 255,
    255, 255, 0, 117, 110, 105, 113, 117, 101, 0, 252, 255,
    255, 255, 0, 110, 97, 109, 101, 0, 245, 255, 255, 255, 0,
    115, 111, 99, 107, 101, 116, 115, 0, 242, 255, 255, 255,
    0, 254, 255, 255, 255, 0, 97, 112, 112, 101, 97, 114, 97,
    110, 99, 101, 115, 0, 242, 255, 255, 255, 0, 251, 255,
    255, 255, 0, 0, 0, 0, 0
    };
  }

  [global::System.CodeDom.Compiler.GeneratedCode("bebopc", "3.1.3")]
  [global::Bebop.Attributes.BebopRecord(global::Bebop.Runtime.BebopKind.Struct)]
  public partial class BebopItem : global::Bebop.Runtime.BaseBebopRecord, global::Bebop.Runtime.IDecodable<BebopItem>, global::System.IEquatable<BebopItem> {
    /// <inheritdoc />
    public sealed override int MaxByteCount => GetMaxByteCount();
    /// <inheritdoc />
    public sealed override int ByteCount => GetByteCount();
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public uint IdClassIdSubclassId { get; init; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public byte BindTypeExpansion { get; init; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public byte PrimaryStatQuality { get; init; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public long RaceMask { get; init; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public int ClassMask { get; init; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public byte Flags { get; init; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public byte InventoryType { get; init; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public short ItemLevel { get; init; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public short Unique { get; init; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public string Name { get; init; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public global::System.Collections.Immutable.ImmutableArray<byte> Sockets { get; init; }
    [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull]
    public uint[] Appearances { get; init; }

    /// <summary>
    /// </summary>
    public BebopItem() : base() { }
    /// <summary>
    /// </summary>
    /// <param name="idClassIdSubclassId">
    /// </param>
    /// <param name="bindTypeExpansion">
    /// </param>
    /// <param name="primaryStatQuality">
    /// </param>
    /// <param name="raceMask">
    /// </param>
    /// <param name="classMask">
    /// </param>
    /// <param name="flags">
    /// </param>
    /// <param name="inventoryType">
    /// </param>
    /// <param name="itemLevel">
    /// </param>
    /// <param name="unique">
    /// </param>
    /// <param name="name">
    /// </param>
    /// <param name="sockets">
    /// </param>
    /// <param name="appearances">
    /// </param>
    public BebopItem([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] uint idClassIdSubclassId, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] byte bindTypeExpansion, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] byte primaryStatQuality, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] long raceMask, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] int classMask, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] byte flags, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] byte inventoryType, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] short itemLevel, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] short unique, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] string name, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] global::System.Collections.Immutable.ImmutableArray<byte> sockets, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] uint[] appearances) => (IdClassIdSubclassId, BindTypeExpansion, PrimaryStatQuality, RaceMask, ClassMask, Flags, InventoryType, ItemLevel, Unique, Name, Sockets, Appearances) = (idClassIdSubclassId, bindTypeExpansion, primaryStatQuality, raceMask, classMask, flags, inventoryType, itemLevel, unique, name, sockets, appearances);
    public BebopItem([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] BebopItem original) => (IdClassIdSubclassId, BindTypeExpansion, PrimaryStatQuality, RaceMask, ClassMask, Flags, InventoryType, ItemLevel, Unique, Name, Sockets, Appearances) = (original.IdClassIdSubclassId, original.BindTypeExpansion, original.PrimaryStatQuality, original.RaceMask, original.ClassMask, original.Flags, original.InventoryType, original.ItemLevel, original.Unique, original.Name, original.Sockets, original.Appearances);
    public void Deconstruct([global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out uint idClassIdSubclassId, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out byte bindTypeExpansion, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out byte primaryStatQuality, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out long raceMask, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out int classMask, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out byte flags, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out byte inventoryType, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out short itemLevel, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out short unique, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out string name, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out global::System.Collections.Immutable.ImmutableArray<byte> sockets, [global::System.Diagnostics.CodeAnalysis.NotNull, global::System.Diagnostics.CodeAnalysis.DisallowNull] out uint[] appearances) => (idClassIdSubclassId, bindTypeExpansion, primaryStatQuality, raceMask, classMask, flags, inventoryType, itemLevel, unique, name, sockets, appearances) = (IdClassIdSubclassId, BindTypeExpansion, PrimaryStatQuality, RaceMask, ClassMask, Flags, InventoryType, ItemLevel, Unique, Name, Sockets, Appearances);

    /// <summary>Calculates the maximum number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetMaxByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint);
      byteCount += sizeof(byte);
      byteCount += sizeof(byte);
      byteCount += sizeof(long);
      byteCount += sizeof(int);
      byteCount += sizeof(byte);
      byteCount += sizeof(byte);
      byteCount += sizeof(short);
      byteCount += sizeof(short);
      byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetMaxByteCount(Name.Length);
      byteCount += sizeof(uint) + Sockets.Length * 1;
      byteCount += sizeof(uint) + Appearances.Length * 4;
      return byteCount;
    }


    /// <summary>Calculates the number of bytes produced by encoding the current record.</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    private protected int GetByteCount() {
      int byteCount = 0;
      byteCount += sizeof(uint);
      byteCount += sizeof(byte);
      byteCount += sizeof(byte);
      byteCount += sizeof(long);
      byteCount += sizeof(int);
      byteCount += sizeof(byte);
      byteCount += sizeof(byte);
      byteCount += sizeof(short);
      byteCount += sizeof(short);
      byteCount += sizeof(uint) + global::System.Text.Encoding.UTF8.GetByteCount(Name);
      byteCount += sizeof(uint) + Sockets.Length * 1;
      byteCount += sizeof(uint) + Appearances.Length * 4;
      return byteCount;
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Wowthing.Tool.Models.BebopItem record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override byte[] Encode(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static byte[] Encode(global::Wowthing.Tool.Models.BebopItem record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably() {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Wowthing.Tool.Models.BebopItem record) {
      var writer = global::Bebop.Runtime.BebopWriter.Create();
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(this, ref writer);
      return writer.ToImmutableArray();
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::System.Collections.Immutable.ImmutableArray<byte> EncodeImmutably(global::Wowthing.Tool.Models.BebopItem record, int initialCapacity) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(initialCapacity);
      __EncodeInto(record, ref writer);
      return writer.ToImmutableArray();
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public sealed override int EncodeIntoBuffer(byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(this, ref writer);
    }
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static int EncodeIntoBuffer(global::Wowthing.Tool.Models.BebopItem record, byte[] outBuffer) {
      var writer = global::Bebop.Runtime.BebopWriter.Create(outBuffer);
      return __EncodeInto(record, ref writer);
    }

    #region Static Decode Methods
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Wowthing.Tool.Models.BebopItem Decode(byte[] record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Wowthing.Tool.Models.BebopItem Decode(global::System.ReadOnlySpan<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Wowthing.Tool.Models.BebopItem Decode(global::System.ReadOnlyMemory<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Wowthing.Tool.Models.BebopItem Decode(global::System.ArraySegment<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    public static global::Wowthing.Tool.Models.BebopItem Decode(global::System.Collections.Immutable.ImmutableArray<byte> record) {
      var reader = global::Bebop.Runtime.BebopReader.From(record);
      return __DecodeFrom(ref reader);
    }

    #endregion
    #region Internal Use
    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static int __EncodeInto(global::Wowthing.Tool.Models.BebopItem record, ref global::Bebop.Runtime.BebopWriter writer) {
      var before = writer.Length;
      writer.WriteUInt32(record.IdClassIdSubclassId);
      writer.WriteByte(record.BindTypeExpansion);
      writer.WriteByte(record.PrimaryStatQuality);
      writer.WriteInt64(record.RaceMask);
      writer.WriteInt32(record.ClassMask);
      writer.WriteByte(record.Flags);
      writer.WriteByte(record.InventoryType);
      writer.WriteInt16(record.ItemLevel);
      writer.WriteInt16(record.Unique);
      writer.WriteString(record.Name);
      writer.WriteBytes(record.Sockets);
      {
        var length0 = unchecked((uint)record.Appearances.Length);
        writer.WriteUInt32(length0);
        for (var i0 = 0; i0 < length0; i0++) {
          writer.WriteUInt32(record.Appearances[i0]);
        }
      }
      var after = writer.Length;
      return after - before;
    }


    /// <summary>DO NOT CALL THIS METHOD DIRECTLY!</summary>
    [global::System.Runtime.CompilerServices.MethodImpl(global::Bebop.Runtime.BebopConstants.HotPath)]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
    internal static global::Wowthing.Tool.Models.BebopItem __DecodeFrom(ref global::Bebop.Runtime.BebopReader reader) {

      uint field0;
      field0 = reader.ReadUInt32();
      byte field1;
      field1 = reader.ReadByte();
      byte field2;
      field2 = reader.ReadByte();
      long field3;
      field3 = reader.ReadInt64();
      int field4;
      field4 = reader.ReadInt32();
      byte field5;
      field5 = reader.ReadByte();
      byte field6;
      field6 = reader.ReadByte();
      short field7;
      field7 = reader.ReadInt16();
      short field8;
      field8 = reader.ReadInt16();
      string field9;
      field9 = reader.ReadString();
      global::System.Collections.Immutable.ImmutableArray<byte> field10;
      field10 = reader.ReadBytes();
      uint[] field11;
      {
        var length0 = unchecked((int)reader.ReadUInt32());
        field11 = new uint[length0];
        for (var i0 = 0; i0 < length0; i0++) {
          uint x0;
          x0 = reader.ReadUInt32();
          field11[i0] = x0;
        }
      }
      return new global::Wowthing.Tool.Models.BebopItem {
        IdClassIdSubclassId = field0,
        BindTypeExpansion = field1,
        PrimaryStatQuality = field2,
        RaceMask = field3,
        ClassMask = field4,
        Flags = field5,
        InventoryType = field6,
        ItemLevel = field7,
        Unique = field8,
        Name = field9,
        Sockets = field10,
        Appearances = field11,
      };
    }

    #endregion
    #region Equality
    public bool Equals(global::Wowthing.Tool.Models.BebopItem other) {
      if (ReferenceEquals(null, other)) {
        return false;
      }
      if (ReferenceEquals(this, other)) {
        return true;
      }
      return IdClassIdSubclassId == other.IdClassIdSubclassId && BindTypeExpansion == other.BindTypeExpansion && PrimaryStatQuality == other.PrimaryStatQuality && RaceMask == other.RaceMask && ClassMask == other.ClassMask && Flags == other.Flags && InventoryType == other.InventoryType && ItemLevel == other.ItemLevel && Unique == other.Unique && Name == other.Name && (Sockets == null ? other.Sockets == null : other.Sockets != null && global::System.Linq.Enumerable.SequenceEqual(Sockets, other.Sockets)) && (Appearances is null ? other.Appearances is null : other.Appearances is not null && global::System.Linq.Enumerable.SequenceEqual(Appearances, other.Appearances));
    }

    public override bool Equals(object obj) {
      if (ReferenceEquals(null, obj)) {
        return false;
      }
      if (ReferenceEquals(this, obj)) {
        return true;
      }
      if (obj is not global::Wowthing.Tool.Models.BebopItem baseType) {
        return false;
      }
      return Equals(baseType);
    }

    public override int GetHashCode() {
      int hash = 1;
      hash ^= IdClassIdSubclassId.GetHashCode();
      hash ^= BindTypeExpansion.GetHashCode();
      hash ^= PrimaryStatQuality.GetHashCode();
      hash ^= RaceMask.GetHashCode();
      hash ^= ClassMask.GetHashCode();
      hash ^= Flags.GetHashCode();
      hash ^= InventoryType.GetHashCode();
      hash ^= ItemLevel.GetHashCode();
      hash ^= Unique.GetHashCode();
      hash ^= Name.GetHashCode();
      hash ^= Sockets.GetHashCode();
      hash ^= Appearances.GetHashCode();
      return hash;
    }

    public static bool operator ==(global::Wowthing.Tool.Models.BebopItem left, global::Wowthing.Tool.Models.BebopItem right) => Equals(left, right);
    public static bool operator !=(global::Wowthing.Tool.Models.BebopItem left, global::Wowthing.Tool.Models.BebopItem  right) => !Equals(left, right);
    #endregion

  }

}
